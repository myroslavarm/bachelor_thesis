\chapter{Introduction}
\label{chap:Introduction}

\section{Context}
\label{sec:Introduction-Context}
Code completion is one of the most used features in any IDE. Whether it is being used for improving speed and accuracy of typing, or is used as an API guide, helping developers find their way around libraries, code completion is one of the first things a developer notices as soon as they start coding. The speed with which the results are suggested, as well as their accuracy is very important, and it is something that can certainly "make or break" the workflow of the developer. Therefore, researchers and software engineers are always trying to find new approaches that can improve code completion quality and make it as effective, as accurate, and as fast\footnote{By "fast" we mean that the completion is quick to give suggestions, by "accurate" that the completion proposes contextually correct results, and by "effective" we mean that the combination of both the aforementioned qualities makes the tool successful in achieving the result, which is to find the most suitable completion as easily as possible.} as possible.

The main distinction among the many approaches to code completion would be whether the approach uses semantic context or not. Namely, semantic models are models that use code structure analysis to tailor completions to type and/or semantic role, or, in other words, to give contextually correct and relevant results. Machine learning models can also often employ semantic analysis but very often treat source code more like simple text, with context not taken into consideration.

Throughout this project, I focused on the code completion in Pharo. Pharo is a dynamically typed programming language inspired by Smalltalk, and the Pharo IDE is an interactive IDE intended for developing in Pharo\footnote{\url{http://pharo.org/}}.

The current code completion approach in the Pharo IDE is a semantic one: it is based on analysing the abstract syntax tree (AST) of source code. The parser finds the best suitable node for each part of code, and the completion engine suggests contextually relevant completions for each one (i.e. class names for a global node, method calls for a method node, and so on). The AST-based approach replaced the less accurate completion engine, which used a less sophisticated parsing implementation and tried to infer the type by looking at messages sent to a variable, and so on. Recently, a separate code completion engine that uses \notclear{generators} was ported to Pharo as well \notclear{(the idea is to propose code completion suggestions from pre-generated local contexts using heuristics for optimisation)}\footnote{GitHub repository for the project: \url{https://github.com/guillep/complishon}}.

\section{Problem}
\label{sec:Introduction-Problem}
As mentioned above, the current implementation of code completion in the Pharo IDE is based on the AST, which allows us to determine the structure of the code, get the semantic role of tokens, and infer their type where possible, to suggest only those completions that are correct in the given context.

\remove{Then, once we have a list of contextually suitable completion candidates, they are sorted alphabetically} \footnote{Implementing AST-based completion in Pharo was the focus of an internship project, and alphabetic sorting was made the default through lack of time to implement a more advanced sorting strategy. However, the possibilities of further extending the tool with other sorting strategies were kept in mind, and this bachelor thesis project serves as a continuation of that task.}. \remove{This is not the most effective approach, as the process of finding the desired completion candidate can be a bit cumbersome: the correct suggestions can be buried much lower than expected, which would prompt the developer to either scroll through the list, or to type even more characters, taking up valuable time and effort.}\oz{I suggest that you don't mention alphabetic sorting at all until you get to the evaluation section. It is obviously ineffective to sort by alphabet. So if your research problem is to find something better then alphabetic sorting, then everything is better. Instead, I would put it this way: (1) currently there is no way to effectively sort the completion candidates; (2) we propose to sort them using n-gram models; (3) we evaluate our approach by comparing alphabetic, unigram, and bigram sorting (in this case, alphabetic sorting acts like a random baseline)} However, \badstyle{as been mentioned} above, the \badstyle{attempts to make code completion more effective are never-ending, and we, too, believe that there are more potential improvements that can be made in the Pharo IDE}. In particular, we think the \badstyle{quality of performance} of the current completion engine can be greatly improved by sorting candidate completions according to how frequently they are used elsewhere in the codebase.

\oz{Problem statement is still not clear. Try expressing it with one sentence and writing it in bold}

\section{Our Approach in a Nutshell}
\label{sec:Introduction-Approach}
In this work we study how code completion can be improved using statistical language models for sorting the results, on top of an existing semantic completion. In particular, we use the N-gram language model, as it has been documented to be used for such a task (\cite{Hind12a}), to find the most relevant completion suggestions based on their occurence in source code. We then implement a sorting strategy based on the \badstyle{counted above relevance of suggestions} \notclear{in the Pharo IDE itself}. We evaluate whether this approach indeed enhances the quality of code completion. We answer the following research questions:
\begin{RQ}
    \item Can we improve the accuracy of code completion in the Pharo IDE by sorting candidate completions with an N-gram language model?
    \item Can we build a tool based on a trained N-gram model that would propose completion fast enough to be actually suitable for developer use? \oz{Do you answer this question in your work?}\oz{Just move it to the next section. This is a contribution, not a research question.}
    \item How can we best numerically evaluate the results of code completion produced by different completion strategies?
\end{RQ}

\section{Contributions}
\label{sec:Introduction-Contributions}
The contributions of this work are as follows:
\begin{itemize}
    \item \insertion{We enhanced the open source library that implements N-gram language models in Pharo: \url{https://github.com/pharo-ai/NgramModel} (4 accepted pull requests)}
    \item We trained several N-gram language models on the tokenised source code of the Pharo programming language.
    \item We used those trained models to enhance code completion in Pharo IDE by sorting the proposed completion candidates according to their relevance in the given context (X accepted pull requests, Y pull requests under review) \oz{Fill in X and Y}
    \item We propose a combination of two approaches for evaluating the results of code completion: (1) a quantitative evaluation technique inspired by \cite{Robb08a} and (2) a qualitative evaluation where we perform a case study of  several completion scenarios.
    \item To our knowledge, this is the first implementation of a code completion engine in Smalltalk family of IDEs that uses machine learning for sorting completion candidates.
    \item \insertion{Part of this work was accepted at an International Workshop XYZ and will be presented by Myroslava Romaniuk in MONTH 2020}\oz{Fill in XYZ and MONTHx}
\end{itemize}

\section{Structure of the Thesis}
\label{sec:Introduction-Structure}
{\hypersetup{linkcolor=black}
\begin{description}
	\item [Chapter \ref{chap:RelatedWorks}. \nameref{chap:RelatedWorks}] \hfill \\
	Here we give a detailed overview of the research done around code completion in the last decade and a half. It includes both the solely software engineering approaches predating the use of machine learning for this task, as well as exclusively machine learning experiments of the recent years.
    \item [Chapter \ref{chap:PharoCompletion}. \nameref{chap:PharoCompletion}] \hfill \\
	In this chapter, we give a detailed overview of the implementation details behind the current completion engine in the Pharo IDE, challenges of code completion for a dynamically typed language, as well as describe the idea behind the sorter plugin.
	\item [Chapter \ref{chap:NgramBackground}. \nameref{chap:NgramBackground}] \hfill \\
    Here we provide a theoretical background needed to understand this work, which includes the introduction to language models in general and n-grams in particular.
    \item [Chapter \ref{chap:ProposedSolution}. \nameref{chap:ProposedSolution}] \hfill \\
	In this chapter, we take a more detailed look at \badstyle{the idea of our solution} and give an extended description of the experiment.
	\item [Chapter \ref{chap:Evaluation}. \nameref{chap:Evaluation}] \hfill \\
    In this chapter, we go into depth about evaluation techniques and challenges, as well as detail the evaluation \insertion{of} \badstyle{approach taken} and the \repetition{results of this work}.
    \item [Chapter \ref{chap:Conclusion}. \nameref{chap:Conclusion}] \hfill \\
	In this chapter, we summarise the \repetition{results of this work} and discuss the potential directions in which it \badstyle{can be taken} in the future.
\end{description}
}