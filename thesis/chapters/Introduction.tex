\chapter{Introduction}
\label{chap:Introduction}

\section{Context}
\label{sec:Introduction-Context}
Code completion is one of the most used features in any IDE. Whether it is being used for improving speed and accuracy of typing, or is used as an API guide, helping developers find their way around libraries, code completion is an essential part of any successful IDE or a code editor.

Code completion is used as a major productivity tool, and is one of the first things a developer notices as soon as they start coding. The speed with which the results are suggested, as well as their accuracy is very important, and it is something that can certainly "make or break" the workflow of the developer. Therefore, researches and software engineers are always trying to find new approaches that can improv code completion quality and make it effective, as accurate, and as fast \footnote{By "fast" we mean that the completion is quick to give suggestions, by "accurate" that the completion proposes contextually correct results, and by "effective" we mean that the combination of both the aforementioned qualities makes the tool successful in achieving the result, which is to find the most suitable completion as easily as possible.} as possible.

The main distinction among the many approaches to completion code would be whether the approach uses semantic context or not. Semantic models use code structure analysis to tailor completions to type and/or semantic role. Statistical or machine learning models can also often employ semantic analysis but would normally be used solely with code history analysis. In this case, the source code would be treated more like simple text, with semantic roles not taken into consideration.

Moving onto the one code completion engine we are particularly interested in, in the last couple of years there have been several approaches taken to improve the completion inside the Pharo IDE \footnote{The name Pharo refers both to the dynamically typed programming language that is a dialect of Smalltalk, as well as the interactive IDE where this language is used. \newline From now on when referring to the language itself we will simply say \textit{Pharo}, whereas when referring to the IDE we will say \textit{the Pharo IDE} (\url{http://pharo.org/})}.

The current code completion approach is a semantic one: it is based on analysing abstract syntax tree (AST) information of source code, taking the best suitable node, and suggesting specifically tailored completions for each one (i.e. class names for a global node, method calls for a method node, and so on). This is something that we implemented a year ago to replace the less accurate "old" completion engine, which used a simpler kind of parser and then was trying to infer the semantic information from other data. Recently, a separate code completion engine that uses generators was ported to Pharo as well, as a possible alternative version that can be used (the idea is to propose code completion suggestions from pre-generated local contexts using heuristics for optimisation) \footnote{GitHub repository for the project: \url{https://github.com/guillep/complishon}}.

\section{Problem}
\label{sec:Introduction-Problem}
As mentioned above, the current main implementation of code completion in the Pharo IDE is based on parsing and analysing AST information of source code, where we are able to determine the structure of the code, get the semantic role of tokens, as well as infer the type information where possible, with the objective being to only suggest completions that are correct in the given context.

Then, once we have a list of contextually suitable completion candidates, they are sorted alphabetically \footnote{Implementing AST-based completion in Pharo was the focus of an internship project, and alphabetic sorting was made the default through lack of time to implement a more advanced sorting strategy. However, the possibilities of further extending the tool with other sorting strategies were kept in mind, and this bachelor thesis project serves as a continuation of that task.}. This is not the most effective approach, as the process of finding the desired completion candidate can be a bit cumbersome: the correct suggestions can be buried much lower than expected, which would prompt the developer to either scroll through the list, or to type even more characters, taking up valuable time and effort. However, as been mentioned above, the attemps to make code completion more effective are never-ending, and we, too, believe that there are more potential improvements that can be made in the Pharo IDE. In particular, we think the quality of performance of the current completion engine can be greatly improved by taking into account the relevance of suggestions by analysing their use throughout source code history and sorting the results based on that.

\section{Our Approach in a Nutshell}
\label{sec:Introduction-Approach}
Hence, in this work we study how code completion can be improved using statistical language models for sorting the results, on top of an already existing semantic completion. In particular, we use the N-gram language model, as it has been documented to be used for such a task (\cite{Hind12a}), to find the most relevant completion suggestions based on their occurence in code history. We then implement a sorting strategy based on the counted above relevance of suggestions in the Pharo IDE itself. Finally, we evaluate whether this approach indeed enhances the quality of code completion. As a result, we answer the following questions:
\begin{itemize}
    \item Can we improve code completion in the Pharo IDE by sorting candidate completions with an N-gram language model?
    \item Can we build a tool based on a trained N-gram model that would propose completion fast enough to be actually suitable for developer use? \oz{Do you answer this question in your work?}
    \item How can we best numerically evaluate the results of code completion produced by different completion strategies?
\end{itemize}

\section{Contributions}
\label{sec:Introduction-Contributions}
The contributions of this work are as follows:
\begin{itemize}
    \item We develop and train N-gram (in particular, uni- (N=1) and bigram (N=2)) language models on the tokenised source code of a dynamically-typed programming language (Pharo)
    \item We implement the sorting functionality based on the results of the above-mentioned training in an open source IDE
    \item We test whether the combination of semantic-based completion and statistical-based sorting can indeed improve the performance of a code completion engine in an IDE and be effective enough to be used by real developers
    \item To our knowledge, this exact approach of separately considering these two parts (i.e. using one known completion approach for the completion engine and another for the sorting of candidates, and separately assembling them together) has not been done before, and in addition nothing of the sort has been implemented in other Smalltalk-centric IDEs
\end{itemize}

\section{Structure of the Thesis}
\label{sec:Introduction-Structure}
{\hypersetup{linkcolor=black}
\begin{description}
	\item [Chapter \ref{chap:RelatedWorks}. \nameref{chap:RelatedWorks}] \hfill \\
	Here we give a detailed overview of the research done around code completion in the last decade and a half. It includes both the solely software engineering approaches predating the use of machine learning for this task, as well as exclusively machine learning experiments of the recent years.
    \item [Chapter \ref{chap:PharoCompletion}. \nameref{chap:PharoCompletion}] \hfill \\
	In this chapter, we give a detailed overview of the implementation details behind the current completion engine in the Pharo IDE, challenges of code completion for a dynamically typed language, as well as describe the idea behind the sorter plugin.
	\item [Chapter \ref{chap:NgramBackground}. \nameref{chap:NgramBackground}] \hfill \\
    Here we provide a theoretical background needed to understand this work, which includes the introduction to the concept of language models in general and N-grams in particular, as well as examples and associated challenges.
    \item [Chapter \ref{chap:ProposedSolution}. \nameref{chap:ProposedSolution}] \hfill \\
	In this chapter, we take a more detailed look at the idea of our solution, as well as give an extended description of the experiment.
	\item [Chapter \ref{chap:Evaluation}. \nameref{chap:Evaluation}] \hfill \\
	In this chapter, we go into depth about evaluation techniques and challenges, as well as detail the evaluation approach taken and the results of this work.
\end{description}
}