\chapter{Introduction}
\label{chap:Introduction}

\section{Context}
\label{sec:Introduction-Context}
\repetition{Code completion is one of the most used features in any IDE.} Whether it is being used for improving speed and accuracy of typing, or is used as an API guide, helping developers find their way around libraries, \repetition{code completion is an essential part of any successful IDE or a code editor.}

Code completion is \remove{used as a major productivity tool, and is} one of the first things a developer notices as soon as they start coding. The speed with which the results are suggested, as well as their accuracy\oz{Move the footnote with the definition of accuracy here} is very important, and it is something that can certainly "make or break" the workflow of the developer. Therefore, researche\insertion{r}s and software engineers are always trying to find new approaches that can improv\insertion{e} code completion quality and make it \insertion{as} effective, as accurate, and as fast \footnote{By "fast" we mean that the completion is quick to give suggestions, by "accurate" that the completion proposes contextually correct results, and by "effective" we mean that the combination of both the aforementioned qualities makes the tool successful in achieving the result, which is to find the most suitable completion as easily as possible.} as possible.

The main distinction among the many approaches to \replace{completion code}{code completion} would be whether the approach uses \notclear{semantic context} or not. \notclear{Semantic models use code structure analysis to tailor completions to type and/or semantic role}. Statistical or machine learning models can also often employ \notclear{semantic analysis} but \wrong{would normally be used solely with code history analysis}. In \notclear{this case}, the source code would be treated more like simple text, with semantic roles not taken into consideration.

\badstyle{Moving onto the one code completion engine we are particularly interested in, in the last couple of years there have been several approaches taken to improve the completion inside the Pharo IDE} \footnote{The name Pharo refers both to the dynamically typed programming language that is a dialect of Smalltalk, as well as the interactive IDE where this language is used. \oz{This first sentence should not be in a footnote, but rather in a normal paragraph ("Pharo is a dynamic ...")} \newline From now on when referring to the language itself we will simply say \textit{Pharo}, whereas when referring to the IDE we will say \textit{the Pharo IDE} (\url{http://pharo.org/})}.

The current code completion approach is a semantic one: it is based on analysing abstract syntax tree (AST) \remove{information} of source code, \notclear{taking the best suitable node, and suggesting specifically tailored completions for each one} (i.e. class names for a global node, method calls for a method node, and so on). \badstyle{This is something that we implemented a year ago} to replace the less accurate \badstyle{"old"} completion engine, which used \notclear{a simpler kind of parser} and then was trying to infer the semantic information from \notclear{other data}. Recently, a separate code completion engine that uses \notclear{generators} was ported to Pharo as well\remove{, as a possible alternative version that can be used} \notclear{(the idea is to propose code completion suggestions from pre-generated local contexts using heuristics for optimisation)} \footnote{GitHub repository for the project: \url{https://github.com/guillep/complishon}}.

\section{Problem}
\label{sec:Introduction-Problem}
As mentioned above, the current \remove{main} implementation of code completion in the Pharo IDE is based on \replace{parsing and analysing}{the} AST \remove{information} \remove{of source code}, \replace{where we are able}{which allows us} to determine the structure of the code, get the semantic role of tokens, \replace{as well as}{and} infer the\insertion{ir} type \remove{information} where possible, \remove{with the objective being} to \remove{only} suggest \insertion{only those} completions that are correct in the given context.

\remove{Then, once we have a list of contextually suitable completion candidates, they are sorted alphabetically} \footnote{Implementing AST-based completion in Pharo was the focus of an internship project, and alphabetic sorting was made the default through lack of time to implement a more advanced sorting strategy. However, the possibilities of further extending the tool with other sorting strategies were kept in mind, and this bachelor thesis project serves as a continuation of that task.}. \remove{This is not the most effective approach, as the process of finding the desired completion candidate can be a bit cumbersome: the correct suggestions can be buried much lower than expected, which would prompt the developer to either scroll through the list, or to type even more characters, taking up valuable time and effort.}\oz{I suggest that you don't mention alphabetic sorting at all until you get to the evaluation section. It is obviously ineffective to sort by alphabet. So if your research problem is to find something better then alphabetic sorting, then everything is better. Instead, I would put it this way: (1) currently there is no way to effectively sort the completion candidates; (2) we propose to sort them using n-gram models; (3) we evaluate our approach by comparing alphabetic, unigram, and bigram sorting (in this case, alphabetic sorting acts like a random baseline)} However, \badstyle{as been mentioned} above, the \badstyle{attemp\insertion{t}s to make code completion more effective are never-ending, and we, too, believe that there are more potential improvements that can be made in the Pharo IDE}. In particular, we think the \badstyle{quality of performance} of the current completion engine can be greatly improved by \replace{taking into account the relevance of suggestions by analysing their use throughout source code history and sorting the results based on that}{sorting candidate completions according to how frequently they are used elsewhere in the codebase}.

\oz{Problem statement is still not clear. Try expressing it with one sentence and writing it in bold}

\section{Our Approach in a Nutshell}
\label{sec:Introduction-Approach}
\remove{Hence, }in this work we study how code completion can be improved using statistical language models for sorting the results, on top of an \remove{already} existing semantic completion. In particular, we use the N-gram language model, as it has been documented to be used for such a task (\cite{Hind12a}), to find the most relevant completion suggestions based on their occurence in \notclear{code history} \oz{I'm a bit confused when you say "code history". The way I understand it, code history is the history of changes (history of commits). Clearly, you mean something else, so either you should define "code history" or (much better!) not use this term at all. How about "codebase"? (\url{https://en.wikipedia.org/wiki/Codebase})}. We then implement a sorting strategy based on the \badstyle{counted above relevance of suggestions} \notclear{in the Pharo IDE itself}. \remove{Finally, }we evaluate whether this approach indeed enhances the quality of code completion. \remove{As a result, }we answer the following questions:
\begin{itemize}
    \item Can we improve \insertion{the accuracy of} code completion in the Pharo IDE by sorting candidate completions with an N-gram language model?
    \item Can we build a tool based on a trained N-gram model that would propose completion fast enough to be actually suitable for developer use? \oz{Do you answer this question in your work?}\oz{Just move it to the next section. This is a contribution, not a research question.}
    \item How can we best numerically evaluate the results of code completion produced by different completion strategies?
\end{itemize}

\section{Contributions}
\label{sec:Introduction-Contributions}
The contributions of this work are as follows:
\begin{itemize}
    \item \insertion{We enhanced the open source library that implements N-gram language models in Pharo: \url{https://github.com/pharo-ai/NgramModel} (4 accepted pull requests)}
    \item We \remove{develop and }train\insertion{ed several} N-gram \remove{(in particular, uni- (N=1) and bigram (N=2))} language models on the tokenised source code of \remove{a dynamically-typed programming language (Pharo)} Pharo programming language.
    \item \replace{We implement the sorting functionality based on the results of the above-mentioned training in an open source IDE}{We used those trained models to enhance code completion in Pharo IDE by sorting the proposed completion candidates according to their relevance in the given context (X accepted pull requests, Y pull requests under review)} \oz{Fill in X and Y}
    \item \replace{We test whether the combination of semantic-based completion and statistical-based sorting can indeed improve the performance of a code completion engine in an IDE and be effective enough to be used by real developers}{We propose a combination of two approaches for evaluating the results of code completion: (1) a quantitative evaluation technique inspired by \cite{Robb08a} and (2) a qualitative evaluation where we perform a case study of  several completion scenarios}
    \item To our knowledge, this \replace{exact approach of separately considering these two parts (i.e. using one known completion approach for the completion engine and another for the sorting of candidates, and separately assembling them together) has not been done before, and in addition nothing of the sort has been implemented in other Smalltalk-centric IDEs}{is the first implementation of a code completion engine in Smalltalk family of IDEs that uses machine learning for sorting completion candidates.}
    \item \insertion{Part of this work was accepted at an International Workshop XYZ and will be presented by Myroslava Romaniuk in MONTH 2020}\oz{Fill in XYZ and MONTHx}
\end{itemize}

\section{Structure of the Thesis}
\label{sec:Introduction-Structure}
{\hypersetup{linkcolor=black}
\begin{description}
	\item [Chapter \ref{chap:RelatedWorks}. \nameref{chap:RelatedWorks}] \hfill \\
	Here we give a detailed overview of the research done around code completion in the last decade and a half. It includes both the solely software engineering approaches predating the use of machine learning for this task, as well as exclusively machine learning experiments of the recent years.
    \item [Chapter \ref{chap:PharoCompletion}. \nameref{chap:PharoCompletion}] \hfill \\
	In this chapter, we give a detailed overview of the implementation details behind the current completion engine in the Pharo IDE, challenges of code completion for a dynamically typed language, as well as describe the idea behind the sorter plugin.
	\item [Chapter \ref{chap:NgramBackground}. \nameref{chap:NgramBackground}] \hfill \\
    Here we provide a theoretical background needed to understand this work, which includes the introduction to \remove{the concept of} language models in general and N-gram\remove{s} \insertion{models} in particular\remove{, as well as examples and associated challenges}.
    \item [Chapter \ref{chap:ProposedSolution}. \nameref{chap:ProposedSolution}] \hfill \\
	In this chapter, we take a more detailed look at \badstyle{the idea of our solution}\replace{, as well as}{and} give an extended description of the experiment.
	\item [Chapter \ref{chap:Evaluation}. \nameref{chap:Evaluation}] \hfill \\
    In this chapter, we go into depth about evaluation techniques and challenges, as well as detail the evaluation \insertion{of} \badstyle{approach taken} and the \repetition{results of this work}.
    \item [Chapter \ref{chap:Conclusion}. \nameref{chap:Conclusion}] \hfill \\
	In this chapter, we summarise the \repetition{results of this work} and discuss the potential directions in which it \badstyle{can be taken} in the future.
\end{description}
}