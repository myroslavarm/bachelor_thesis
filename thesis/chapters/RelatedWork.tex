\chapter{Related Works}
\label{chap:Related Works}

\section{Earlier Code Completion Systems}
Standard code completions in IDEs used to only rely on language-specific pattern matching, i.e. sorting completions alphabetically based on the symbols already typed in. \cite{Robb08a}, however, showed code completion can be improved by using program history. In particular, they managed to get good results by prioritising suggestions from recently modified method bodies, and even better results by using per-session vocabulary (changes of the last hour) and merging it with type-based completion.

According to \cite{Bruc09a}, up until 10 years ago code completions were exclusively based on static type system of programming languages. The authors countered that by implementing intelligent code completion systems that learned from examples and had a significantly better performance in terms of suggestions relevance than regular completions. The implementations in particular were: the frequency based code completion (frequency of use of code), an association rule based completion, and the Best Matching Neighbours code completion (method calls of the closest source snippet found, using a k-nearest neighbours algorithm modification), which was the main contribution of their paper. The BMN based implementation was integrated into Eclipse and demonstrated promising results. It was later extended by \cite{Prok15a}.

\section{Software naturalness}
In the famous paper "On The Naturalness of Software", \cite{Hind12a} compared source code to natural languages. They claim that code is even more repetitive, predictable and full of patterns than human languages. In the paper, they also argue that code can be modelled by statistical language models, which can be used to support software engineers. Their approach was based on capturing high-level statistical regularity at the n-gram level by taking n-1 previous tokens that are already entered into the text buffer, and attempting to guess the next token. Using this model, it is possible to estimate the most probable sequences of tokens and suggest the most relevant code completions to developers.

The work by \cite{Hind12a} served as a sort of catalyst for the following research. For instance, \cite{Tu14a} also learnt that code "has a high degree of localness, where identifiers (e.g. variable names) are repeated often within close distance" (\cite{Alla18a}). Thus, they applied a cache mechanism that assigns higher probability to tokens that have been observed most recently, and were able to improve the results even further.

\cite{Nguy13a} improved the state-of-the-art n-gram approach by incorporating semantic information into code tokens, rather than treating them as text -- i.e. annotating each token with its data type and semantic role if available, which allowed them to even further increase predictability. However, of course, the experiment was only configured for Java and C\#, and is not quite as applicable to dynamically typed programming languages.

\section{Deep Learning for Code Completion}
In the more recent years, researches started applying deep learning models such as deep recurrent neural networks.

For instance, \cite{Hell19a} recorded the results of a case study of 15,000 completions (completion events) for VisualStudio. One of the conclustions they've reached is that even though RNNs often outperform n-gram models in typical natural language settings, n-gram models are sometimes a better choice for modeling source code. For example, the deep learner is better at core method invocations but loses on third-party library calls, whereas the n-gram model naturally outperforms it on internal API calls but loses out on the other categories.

\cite{Prok15a} worked on an extensible inference engine for intelligent code completion systems, called PatternBased Bayesian Network (PBN). Eclipse Code Recommenders6 project adapted the PBN approach for their intelligent call completion. They've also tested (evaluating quality, speed and model size) Best Matching Neighbour algorithm, using additional context information for more precise recommendations, and applying clustering techniques to improve model sizes. They've reached the following conclusions: showing the developer hundreds of recommendations may be as ineffective as showing none, and intelligent code completions better target the needs of developers that are unfamiliar with an API.

\cite{Hell17a} introduced a dynamically updatable, nested scope, unlimited vocabulary count-based N-gram model which outperformed both the traditional N-gram models and the deep learning RNN and LSTM models.

\cite{Li17a} developed an attention mechanism which exploits the parent-children information of the code AST. As correctly predicting out-of-vocabulary (OoV) values in code completion is largely unsuccessful, the authors implemented a pointer mixture network which either generates a new value through an RNN component, or copies an OoV value from local context through a pointer component.

\cite{Rayc14a} implemented a tool called SLANG, which Ô¨Årst extracts abstract histories from the data. Then, these histories are fed to a language model such as an n-gram model or recurrent neural network model, which treats the histories as sentences in a natural language and learns probabilities for each sentence, not at all taking into considering code AST information.