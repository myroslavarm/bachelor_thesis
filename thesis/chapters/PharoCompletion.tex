\chapter{Completion in Pharo}
\label{chap:PharoCompletion}

In this chapter, we give a detailed overview of \remove{the implementation details behind} the current completion engine in the Pharo IDE\replace{,}{as well as} challenges of code completion for a dynamically typed language, \replace{as well as}{and} describe the idea behind the sorter plugin.

\section{Code Completion Background}
\label{sec:PharoCompletion-Background}
\remove{So, first things first.} The Pharo programming language is an object-oriented dynamically typed programming language with a Smalltalk-like syntax. The Pharo IDE is a programming environment meant specifically for developing in Pharo. \notclear{\replace{You have}{It consists of} a virtual machine (VM), on top of which an image can be run, which, \remove{referencing other IDEs, sort of} serves as the current IDE workspace.}

\remove{The interesting thing here is that }the Pharo IDE itself is written in Pharo, and can be extended from within. This means that when implementing code completion, you can be testing it live in the very environment where you are developing it, which, \remove{of course}, if not done carefully, can lead you to breaking the system. \remove{However, this pecularity is still an immense advantage with a project like this.}

\remove{Now,} code completion in the Pharo IDE is called at every keystroke, after we have typed two and more alphabetic characters. We create a completion context for all the text typed up until then, be it in the Playground or in the \replace{Editor}{System Browser}\remove{.} (\remove{Essentially, }the Playground is a tool for \replace{generating}{writing} small scripts and sketching out some code, whereas the \replace{Editor}{System Browser} is where you write and edit code for a particular method of a class, i.e. the place to implement the functionality of your classes; \replace{Fig.}{Figure} \ref{fig:playground} and \ref{fig:editor}).

\section{Typing for Completion in Dynamic Languages}
\label{sec:PharoCompletion-Typing}
As Pharo is a dynamically typed language, the precise type information is only available at runtime. This is \remove{of course} tricky for code completion, because the type is not known at the moment of typing, which can make the completion suggestions for message sends appear too general. This is ineffective, as often the specific completion the developer has in mind can be too far down \insertion{in} the list of suggestions and it would require scrolling \remove{through the suggestions list,} or typing more characters.

There are a couple of approaches one could take to solve this. The first is type inference (or rather type reconstruction), which can be done by extracting \notclear{interface types} by looking at the messages sent to a variable, and merging these results with types found by heuristics \replace{working on}{applied to the} right-hand side of assignment expressions (\cite{Pluq09a}). Type guessing by means of name analysis can also be done, but \insertion{it} is more likely to be misleading. The third approach\replace{, which is the one taken with}{involves} the AST-based completion in the Pharo IDE (more details in the next section)\replace{, involves}{. It} perform\replace{ing}{s} a semantic analysis of source code, which \replace{allows to get}{provides us with more} accurate type information for certain kinds of nodes.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{images/completion1.png}
    \caption{Completion in the Playground}
    \label{fig:playground}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{images/completion2.png}
    \caption{Completion in the \replace{Editor}{System Browser}}
    \label{fig:editor}
\end{figure}

\section{AST-Based Completion}
\label{sec:PharoCompletion-ASTCompletion}
\badstyle{The approach behind implementing the AST-based completion is as follows:}

\notclear{The completion context parses the text and transforms it into the AST representation, such as a sequence of AST nodes.} \oz{What is this "completion context"? How can context parse anything?} In the process\insertion{,} all the information needed for further actions \badstyle{is extracted}: \remove{for example, we get} the \replace{currect}{current} position of the cursor (i.e. where we want to get the completion) and the class \replace{where}{which} we are currently \replace{operating}{modifying} (or information that \badstyle{it's} in the Playground). \badstyle{Doing the semantic analysis}, we get the most fitting type of node for each \wrong{part of code}, and then \notclear{go to each node} \oz{How can we "go" to a node?} to get the \notclear{correct completion behaviour} \oz{What is "completion behaviour"?}. For instance, this means that for a Global node, we want to \remove{be} suggest\remove{ed} all the globals, such as class names, for a Message node we only want to get message sends to a variable \badstyle{(in other words, method calls applicable to a certain class instance)}, and so on.

Combining the available \notclear{symbol prefix} \oz{What is "symbol prefix"?} \badstyle{of length 2 and more that we have}, as well as relevant semantic information, we \remove{are able to} give a list of fitting completion suggestions that \badstyle{are then passed to} the sorter \remove{and, in the default Pharo IDE completion, are sorted alphabetically.} \oz{Again, don't mention alphabetic sorting. It was you who added it, and it was only a temporary solution. But you make it sound as if this was some default behaviour that we have been using for years and now you are here to change it} The list itself is displayed in a completion menu that pops up once the completion \badstyle{is called} and then is updated with every new keystroke, unless the developer cancels it by pressing \textit{Esc} or clicking \notclear{to the side} of the text area. The completion window can also disappear once there are no valid suggestions to give anymore.

\remove{As has been mentioned above, generally alphabetically sorted completions can be quite inaccurate for variables and method sends of an unknown type. There is, however, one silver lining: to have a sorting strategy that would suggest more contextually relevant results first, and in such a way compensate for a lack of typing precision. For this, we implemented a sorter plugin.}

\section{Sorter Plugin}
\label{sec:PharoCompletion-SorterPlugin}
The sorter plugin is technically a part of the completion but it's implemented separately and is intended for usage even without knowing the details of the completion engine. \oz{Well yes... that's what we mean when we say "plugin"} \remove{Specifically,} \badstyle{within the sorter we treat the completion implementation as a \remove{sort of a} black box, and the only information we receive is the list of completions we want to sort, as well as the context}. This was done to make the sorter extendable and open for modi\insertion{fi}cation \remove{by any developer}, so one could take the general completion functionality and then on top of it put any sorting strategy they would like to have.

\remove{Essentially, }this means that the way we get the completion results \remove{themselves} is \notclear{the same} \oz{Same as what?}, i.e. \notclear{we semantically analyse the source code and try to give relevant nodes as precisely as possible}. However, the sorting strategy \remove{really} matters when it comes to tokens \badstyle{where} we cannot \badstyle{give any precise suggestions by analysis alone, and displaying them in a certain order, that the developer of the sorting strategy hypothesises to be helpful}, can \remove{really} improve the end result (i.e. the list of suggestions displayed in the pop up completion menu). \oz{Please rewrite this sentence... I read it 4 times and I still don't understand what you were trying to say and who "can really improve..."}

\section{Summary}
\label{sec:PharoCompletion-Summary}
\remove{In short, the main things to remember from this chapter are the following:}

\oz{It's already in a word "Summary"}

\oz{And use capital letters}
\begin{itemize}
    \item Pharo is a dynamically typed language\remove{d} \wrong{based on Smalltalk} \oz{I'm not sure if it's correct to say that Pharo is "based on Smalltalk". It's either a dialect of Smalltalk or, according to Stephane, "a new sexy language created in the tradition of Smalltalk". Ask someone what is a correct way to say it}, and the Pharo IDE is a programming environment specifically \oz{designed? created? intended?} for developing in Pharo
    \item code completion in the Pharo IDE is used in two places: the Playground (a scripting tool) and the \replace{Editor}{System Browser} (tool for writing and editing class functionality) \oz{Are you sure? Is there no completion inside Inspector, Debugger, etc.?}
    \item current code completion is based on \badstyle{AST analysis of source code}; it is called after the developer types two alphabetic characters, and the completion candidates are suggested by the most relevant semantic context
    \item \badstyle{there's} a sorter plugin that supports implementing various sorting strategies\remove{; by default completion candidates are sorted alphabetically}
\end{itemize}